Index: src/main/java/course/concurrency/exams/refactoring/MountServiceUpdated.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/refactoring/MountServiceUpdated.java b/src/main/java/course/concurrency/exams/refactoring/MountServiceUpdated.java
new file mode 100644
--- /dev/null	(date 1681220535631)
+++ b/src/main/java/course/concurrency/exams/refactoring/MountServiceUpdated.java	(date 1681220535631)
@@ -0,0 +1,141 @@
+package course.concurrency.exams.refactoring;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.*;
+
+import static java.util.stream.Collectors.toList;
+
+public class MountServiceUpdated {
+
+    private Others.RouterStore routerStore = new Others.RouterStore();
+    private long cacheUpdateTimeout;
+
+    /**
+     * All router admin clients cached. So no need to create the client again and
+     * again. Router admin address(host:port) is used as key to cache RouterClient
+     * objects.
+     */
+    private Others.LoadingCache<String, Others.RouterClient> routerClientsCache;
+
+    /**
+     * Removes expired RouterClient from routerClientsCache.
+     */
+    private ScheduledExecutorService clientCacheCleanerScheduler;
+
+    public void serviceInit()  {
+        long routerClientMaxLiveTime = 15L;
+        this.cacheUpdateTimeout = 10L;
+        routerClientsCache = new Others.LoadingCache<>();
+        routerStore.getCachedRecords().stream().map(Others.RouterState::getAdminAddress)
+                .forEach(addr -> routerClientsCache.add(addr, new Others.RouterClient()));
+
+        initClientCacheCleaner(routerClientMaxLiveTime);
+    }
+
+    public void serviceStop() {
+        clientCacheCleanerScheduler.shutdown();
+        routerClientsCache.cleanUp();
+    }
+
+    private void initClientCacheCleaner(long routerClientMaxLiveTime) {
+        ThreadFactory tf = r -> {
+                Thread t = new Thread();
+                t.setName("MountTableRefresh_ClientsCacheCleaner");
+                t.setDaemon(true);
+                return t;
+            };
+
+        clientCacheCleanerScheduler =
+                Executors.newSingleThreadScheduledExecutor(tf);
+
+        clientCacheCleanerScheduler.scheduleWithFixedDelay(
+                () -> routerClientsCache.cleanUp(), routerClientMaxLiveTime,
+                routerClientMaxLiveTime, TimeUnit.MILLISECONDS);
+    }
+
+    public void refresh()  {
+        List<Others.RouterState> cachedRecords = routerStore.getCachedRecords();
+        List<UpdateTask> refreshTasks = new ArrayList<>();
+        for (Others.RouterState routerState : cachedRecords) {
+            String adminAddress = routerState.getAdminAddress();
+            if (adminAddress == null || adminAddress.length() == 0) {
+                continue;
+            }
+            UpdateTask task = getUpdateTask(adminAddress);
+            refreshTasks.add(task);
+        }
+        if (!refreshTasks.isEmpty()) {
+            invokeRefresh(refreshTasks);
+        }
+    }
+
+    protected UpdateTask getUpdateTask(String address) {
+        if (isLocalAdmin(address)) {
+            return getLocalRefresher(address);
+        } else {
+            return new UpdateTask(new Others.MountTableManager(address), address);
+        }
+    }
+    protected UpdateTask getLocalRefresher(String adminAddress) {
+        return new UpdateTask(new Others.MountTableManager("local"), adminAddress);
+    }
+
+    private void removeFromCache(String adminAddress) {
+        routerClientsCache.invalidate(adminAddress);
+    }
+
+    private void invokeRefresh(List<UpdateTask> updateTasks) {
+        List<CompletableFuture<Void>> res = updateTasks.stream().map(
+                    task ->
+                    CompletableFuture.runAsync(() -> task.process())
+                    .completeOnTimeout(null, cacheUpdateTimeout, TimeUnit.MILLISECONDS)
+                    .exceptionally(ex -> {
+                        log(ex.toString());
+                        return null;
+                    }
+                )).collect(toList());
+
+        CompletableFuture.allOf(res.toArray(CompletableFuture[]::new)).join();
+        logResult(updateTasks);
+    }
+
+    private boolean isLocalAdmin(String adminAddress) {
+        return adminAddress.contains("local");
+    }
+
+    private void logResult(List<UpdateTask> tasks) {
+        int successCount = 0;
+        int failureCount = 0;
+        for (UpdateTask task : tasks) {
+            if (task.isDone()) {
+                successCount++;
+            } else {
+                failureCount++;
+                removeFromCache(task.getAdminAddress());
+            }
+        }
+        if (failureCount != 0) {
+            log("Not all router admins updated their cache");
+        }
+        log(String.format(
+                "Mount table entries cache refresh successCount=%d,failureCount=%d",
+                successCount, failureCount));
+    }
+
+    public void log(String message) {
+        System.out.println(message);
+    }
+
+    public void setCacheUpdateTimeout(long cacheUpdateTimeout) {
+        this.cacheUpdateTimeout = cacheUpdateTimeout;
+    }
+
+    public void setRouterClientsCache(Others.LoadingCache cache) {
+        this.routerClientsCache = cache;
+    }
+
+    public void setRouterStore(Others.RouterStore routerStore) {
+        this.routerStore = routerStore;
+    }
+}
Index: src/main/java/course/concurrency/exams/refactoring/UpdateTask.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/course/concurrency/exams/refactoring/UpdateTask.java b/src/main/java/course/concurrency/exams/refactoring/UpdateTask.java
new file mode 100644
--- /dev/null	(date 1683636192425)
+++ b/src/main/java/course/concurrency/exams/refactoring/UpdateTask.java	(date 1683636192425)
@@ -0,0 +1,27 @@
+package course.concurrency.exams.refactoring;
+
+public class UpdateTask {
+
+    private final Others.MountTableManager manager;
+    private final String adminAddress;
+    private boolean isDone;
+
+    public UpdateTask(Others.MountTableManager manager,
+
+                      String adminAddress) {
+        this.manager = manager;
+        this.adminAddress = adminAddress;
+    }
+
+    public String getAdminAddress() {
+        return adminAddress;
+    }
+
+    public boolean isDone() {
+        return isDone;
+    }
+
+    public void process() {
+        isDone = manager.refresh();
+    }
+}
Index: src/test/java/course/concurrency/exams/refactoring/MountTableRefresherServiceUpdatedTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>windows-1251
===================================================================
diff --git a/src/test/java/course/concurrency/exams/refactoring/MountTableRefresherServiceUpdatedTests.java b/src/test/java/course/concurrency/exams/refactoring/MountTableRefresherServiceUpdatedTests.java
new file mode 100644
--- /dev/null	(date 1681981729769)
+++ b/src/test/java/course/concurrency/exams/refactoring/MountTableRefresherServiceUpdatedTests.java	(date 1681981729769)
@@ -0,0 +1,185 @@
+package course.concurrency.exams.refactoring;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.mockito.Mockito;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static java.util.stream.Collectors.toList;
+import static org.mockito.Mockito.*;
+
+public class MountTableRefresherServiceUpdatedTests {
+
+    private MountServiceUpdated service;
+
+    private Others.RouterStore routerStore;
+    private Others.MountTableManager manager;
+    private Others.LoadingCache routerClientsCache;
+
+    @BeforeEach
+    public void setUpStreams() {
+        service = new MountServiceUpdated();
+        service.setCacheUpdateTimeout(1000);
+        routerStore = mock(Others.RouterStore.class);
+        manager = mock(Others.MountTableManager.class);
+        service.setRouterStore(routerStore);
+        routerClientsCache = mock(Others.LoadingCache.class);
+        service.setRouterClientsCache(routerClientsCache);
+        // service.serviceInit(); // needed for complex class testing, not for now
+    }
+
+    @AfterEach
+    public void restoreStreams() {
+        // service.serviceStop();
+    }
+
+    @Test
+    @DisplayName("All tasks are completed successfully")
+    public void allDone() {
+        MountServiceUpdated mockedService = Mockito.spy(service);
+        when(manager.refresh()).thenReturn(true);
+
+        List<String> addresses = List.of("123", "local6", "789", "local");
+        List<UpdateTask> tasks = addresses.stream().map(addr -> new UpdateTask(manager, addr)).collect(toList());
+
+        AtomicInteger taskIndex = new AtomicInteger(0);
+        when(mockedService.getUpdateTask(anyString())).thenAnswer(inv -> tasks.get(taskIndex.getAndIncrement()));
+
+        List<Others.RouterState> states = addresses.stream()
+                .map(a -> new Others.RouterState(a)).collect(toList());
+        when(routerStore.getCachedRecords()).thenReturn(states);
+
+        mockedService.refresh();
+
+        verify(mockedService).log("Mount table entries cache refresh successCount=4,failureCount=0");
+        verify(routerClientsCache, never()).invalidate(anyString());
+    }
+
+    @Test
+    @DisplayName("All tasks failed")
+    public void noSuccessfulTasks() {
+        MountServiceUpdated mockedService = Mockito.spy(service);
+
+        List<String> addresses = List.of("123", "local6", "789", "local");
+        List<UpdateTask> tasks = addresses.stream().map(a -> new UpdateTask(
+                manager, a
+        )).collect(toList());
+        AtomicInteger taskIndex = new AtomicInteger(0);
+        when(mockedService.getUpdateTask(anyString())).thenAnswer(inv -> tasks.get(taskIndex.getAndIncrement()));
+
+        when(manager.refresh()).thenReturn(false);
+        List<Others.RouterState> states = addresses.stream()
+                .map(a -> new Others.RouterState(a)).collect(toList());
+        when(routerStore.getCachedRecords()).thenReturn(states);
+
+        mockedService.refresh();
+
+        verify(mockedService).log("Not all router admins updated their cache");
+        verify(mockedService).log("Mount table entries cache refresh successCount=0,failureCount=4");
+        addresses.forEach(addr -> verify(routerClientsCache).invalidate(addr));
+    }
+
+    @Test
+    @DisplayName("Some tasks failed")
+    public void halfSuccessedTasks() {
+        MountServiceUpdated mockedService = Mockito.spy(service);
+
+        List<String> addresses = List.of("123", "local6", "789", "local");
+
+        Others.MountTableManager managerSucceed = mock(Others.MountTableManager.class);
+        Others.MountTableManager managerFailed = mock(Others.MountTableManager.class);
+        when(managerFailed.refresh()).thenReturn(false);
+        when(managerSucceed.refresh()).thenReturn(true);
+
+        List<UpdateTask> tasks = new ArrayList<>();
+        tasks.add(new UpdateTask(managerSucceed, addresses.get(0)));
+        tasks.add(new UpdateTask(managerFailed, addresses.get(1)));
+        tasks.add(new UpdateTask(managerSucceed, addresses.get(2)));
+        tasks.add(new UpdateTask(managerFailed, addresses.get(3)));
+
+        AtomicInteger taskIndex = new AtomicInteger(0);
+        when(mockedService.getUpdateTask(anyString())).thenAnswer(inv -> tasks.get(taskIndex.getAndIncrement()));
+
+        List<Others.RouterState> states = addresses.stream()
+                .map(a -> new Others.RouterState(a)).collect(toList());
+        when(routerStore.getCachedRecords()).thenReturn(states);
+
+        mockedService.refresh();
+
+        verify(mockedService).log("Not all router admins updated their cache");
+        verify(mockedService).log("Mount table entries cache refresh successCount=2,failureCount=2");
+        verify(routerClientsCache).invalidate(addresses.get(1));
+        verify(routerClientsCache).invalidate(addresses.get(3));
+    }
+
+    @Test
+    @DisplayName("One task completed with exception")
+    public void exceptionInOneTask() {
+        MountServiceUpdated mockedService = Mockito.spy(service);
+
+        List<String> addresses = List.of("123", "local6", "789", "local");
+
+        Others.MountTableManager managerSucceed = mock(Others.MountTableManager.class);
+        Others.MountTableManager managerExceptioned = mock(Others.MountTableManager.class);
+        when(managerExceptioned.refresh()).thenThrow(new RuntimeException());
+        when(managerSucceed.refresh()).thenReturn(true);
+
+        List<UpdateTask> tasks = new ArrayList<>();
+        tasks.add(new UpdateTask(managerSucceed, addresses.get(0)));
+        tasks.add(new UpdateTask(managerExceptioned, addresses.get(1)));
+        tasks.add(new UpdateTask(managerSucceed, addresses.get(2)));
+        tasks.add(new UpdateTask(managerSucceed, addresses.get(3)));
+
+        AtomicInteger taskIndex = new AtomicInteger(0);
+        when(mockedService.getUpdateTask(anyString())).thenAnswer(inv -> tasks.get(taskIndex.getAndIncrement()));
+
+        List<Others.RouterState> states = addresses.stream()
+                .map(a -> new Others.RouterState(a)).collect(toList());
+        when(routerStore.getCachedRecords()).thenReturn(states);
+
+        mockedService.refresh();
+
+        verify(mockedService).log("java.util.concurrent.CompletionException: java.lang.RuntimeException");
+        verify(mockedService).log("Not all router admins updated their cache");
+        verify(mockedService).log("Mount table entries cache refresh successCount=3,failureCount=1");
+        verify(routerClientsCache).invalidate(addresses.get(1));
+    }
+
+    @Test
+    @DisplayName("One task exceeds timeout")
+    public void oneTaskExceedTimeout() {
+        MountServiceUpdated mockedService = Mockito.spy(service);
+
+        List<String> addresses = List.of("123", "local6", "789", "local");
+
+        Others.MountTableManager managerSucceed = mock(Others.MountTableManager.class);
+        Others.MountTableManager managerTimeout = mock(Others.MountTableManager.class);
+        when(managerTimeout.refresh()).thenAnswer(inv -> {Thread.sleep(2000); return true;});
+        when(managerSucceed.refresh()).thenReturn(true);
+
+        List<UpdateTask> tasks = new ArrayList<>();
+        tasks.add(new UpdateTask(managerSucceed, addresses.get(0)));
+        tasks.add(new UpdateTask(managerTimeout, addresses.get(1)));
+        tasks.add(new UpdateTask(managerSucceed, addresses.get(2)));
+        tasks.add(new UpdateTask(managerSucceed, addresses.get(3)));
+
+        AtomicInteger taskIndex = new AtomicInteger(0);
+        when(mockedService.getUpdateTask(anyString())).thenAnswer(inv -> tasks.get(taskIndex.getAndIncrement()));
+
+        List<Others.RouterState> states = addresses.stream()
+                .map(a -> new Others.RouterState(a)).collect(toList());
+        when(routerStore.getCachedRecords()).thenReturn(states);
+
+        mockedService.refresh();
+
+        verify(mockedService).log("Not all router admins updated their cache");
+        verify(mockedService).log("Mount table entries cache refresh successCount=3,failureCount=1");
+        verify(routerClientsCache).invalidate(addresses.get(1));
+    }
+
+}
